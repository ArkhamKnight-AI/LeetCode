注意：带自定义比较功能的大根堆和小根堆写法！！
priority_queue<int> pq1 // 大根堆
priority_queue<int, vector<int>, greater<int>> pq2 // 小根堆

#include<iostream>
#include<vector>
#include<algorithm>
#include<queue>
#include<unordered_map>
using namespace std;

template <class T>
struct Cmp {
	bool operator()(const T& s1, const T& s2) {
		return s1.second < s2.second;
	}
};

template <class T>
struct Cmp1 {
	bool operator()(const T& s1, const T& s2) {
		return s1.second > s2.second;
	}
};
//
////使用大根堆
//vector<int> topKFrequent(vector<int>& nums, int k) {
//	unordered_map<int, int> map;
//	priority_queue<pair<int, int>, vector<pair<int, int>>, Cmp<pair<int, int>>> q;
//	vector<int> res;
//
//	for (int i = 0; i < nums.size(); i++) {
//		if (map.find(nums[i]) == map.end()) {
//			map.emplace(nums[i], 0);
//		}
//
//		map[nums[i]]++;
//	}
//
//
//	for (auto i : map) {
//		q.push(i);
//	}
//
//	for (int i = 0; i < k; i++) {
//		res.push_back(q.top().first);
//		q.pop();
//	}
//
//	return res;
//}

//使用小根堆
vector<int> topKFrequent(vector<int>& nums, int k) {
	unordered_map<int, int> map;
	priority_queue<pair<int, int>, vector<pair<int, int>>, Cmp1<pair<int, int>>> q;
	vector<int> res;

	for (int i = 0; i < nums.size(); i++) {
		if (map.find(nums[i]) == map.end()) {
			map.emplace(nums[i], 0);
		}

		map[nums[i]]++;
	}

	

	for (auto i : map) {
		if (q.size() < k) {
			q.push(i);
		}

		if (q.size() == k && q.top().second < i.second) {
			q.pop();
			q.push(i);
		}
	}

	for (int i = 0; i < k; i++) {
		res.push_back(q.top().first);
		q.pop();
	}

	return res;
}

int main() {
	vector<int> a = { 4,1,-1,2,-1,2,3 };
	vector<int> res = topKFrequent(a, 2);
	for (auto i : res) {
		cout << i << " ";
	}
	cout << endl;
	system("pause");
	return 0;
}      
