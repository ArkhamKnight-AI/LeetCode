注意:递归的调用时机

#include<iostream>
#include<vector>
#include<stack>
using namespace std;

//弹出栈底元素并返回的操作
int getAndRemoveLastElement(stack<int>& s) {
	int result = s.top();
	s.pop();
	//如果栈空了 将栈底元素返回
	if (s.empty()) {
		return result;
	}

	//否则继续递归 知道栈底
	else {
		//last表示待求的栈底元素
		int last = getAndRemoveLastElement(s);
		//把result压回去 因为只需要取栈底元素
		s.push(result);
		//将递归求取的栈底元素返回
		return last;
	}
}

//使用递归将栈逆序
void reverse_stack(stack<int>& s) {
	if (s.empty()) return;

	//得到栈底元素
	int last = getAndRemoveLastElement(s);
	//递归地调用reverse函数 获取每一时刻的栈底元素
	reverse_stack(s);
	//将栈底元素
	s.push(last);
}


int main(void) {
	vector<int> arr = { 1,2,100,4 };
	stack<int> s;
	s.push(1);
	s.push(3);
	s.push(2);
	s.push(4);
	reverse_stack(s);
	while (!s.empty()) {
		cout << s.top() << " ";
		s.pop();
	}
	system("pause");
	return 0;
}
