struct TreeNode {
	int val;
	TreeNode *left;
	TreeNode *right;
	TreeNode() : val(0), left(nullptr), right(nullptr) {}
	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
	TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

class Solution {
public:
	TreeNode* pre = nullptr;
	int count = 0;  //当前遍历节点的val的数量
	vector<int> res;
	int maxCount = INT_MIN;   //出现最多的val的数量
	vector<int> findMode(TreeNode* root) {
		if (!root) return{};
		process(root);
		return res;
	}

	void process(TreeNode* cur) {
		if (!cur) return;

		//处理cur左子树
		process(cur->left);

		//处理cur节点
		if (!pre) count = 1; //pre为空 说明是第一个节点
		if (pre->val != cur->val) count = 1; //pre的val和cur的val不相同 重置为1
		if (pre->val == cur->val) count++;   //pre的val和cur的val相同 那么该val出现次数++

		if (count == maxCount)  res.push_back(cur->val);

		if (count > maxCount) {
			res.clear();
			res.push_back(cur->val);
			maxCount = count;
		}
		pre = cur; //处理完成后不要忘记更新pre!

		//处理cur的右子树
		process(cur->right);
	}
};
