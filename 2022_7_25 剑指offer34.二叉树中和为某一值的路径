class Solution {
public:
	vector<vector<int>> res;
	vector<int> path;

	vector<vector<int>> findPath(TreeNode* root, int sum) {
		if (root == nullptr) return {};

		process(root, sum);

		return res;
	}

	//遍历到当前节点时 距离sum还剩余多少->rest
	void process(TreeNode* root, int rest) {
		//当前节点为空 说明不是叶节点
		if (!root) return;

		rest -= root->val;

		//将当前节点加入当前路径中
		path.push_back(root->val);

		//判断是否是叶节点 如果左右孩子都是nullptr 则判断是否rest为0
		if (!root->left && !root->right && rest == 0) res.push_back(path); 

		//如果不是叶节点 把结果加入当前路径 则继续在左右子树递归执行
		if (root->left) process(root->left, rest);
		if (root->right) process(root->right, rest);
		
		//一定要记得 遍历完后要恢复原状 因为还需要继续遍历其他节点！
		path.pop_back();
	}
};
