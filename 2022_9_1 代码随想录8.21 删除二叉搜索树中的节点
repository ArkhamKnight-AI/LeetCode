//二叉树
struct TreeNode {
	int val;
	TreeNode *left;
	TreeNode *right;
	TreeNode() : val(0), left(nullptr), right(nullptr) {}
	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
	TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

//递归法
TreeNode* deleteNode(TreeNode* root, int key) {
	if (!root) return root; //情况一 没有找到
	if (root->val == key) {
		//情况二 没有左右孩子 则返回空
		if (!root->left && !root->right) return nullptr;
		//情况三 只有左孩子 左孩子补位
		else if (!root->left) return root->right;
		//情况四 只有右孩子 右孩子补位
		else if (!root->right) return root->left;
		//情况五 左右孩子均不为空
		else {
			TreeNode* cur = root->right;
			//第一步：找到右子树的最左侧节点
			while (cur->left) {
				cur = cur->left;
			}

			//第二步：把root为头的左子树放在右子树最左侧节点的左孩子
			cur->left = root->left;
			TreeNode* tmp = root;
			root = root->right;
			delete tmp;
		}
		
		//第二步：把root为头的左子树放在右子树最左侧节点的左孩子
		if (root->val > key) root->left = deleteNode(root->left, key);
		if (root->val < key) root->right = deleteNode(root->right, key);

		return root;
	}
}

//迭代法
TreeNode* deleteOps(TreeNode* cur) {
	if (!cur) return nullptr;
	if (!cur->right) return cur->left;
	if (!cur->left) return cur->right;

	TreeNode* node = cur->right;
	while (node->left) {
		node = node->left;
	}
	node->left = cur->left;

	return cur->right;
}

TreeNode* deleteNode(TreeNode* root, int key) {
	if (!root) return root;
	if (!root->left && !root->right) {
		return root->val == key ? nullptr : root;
	}
	TreeNode* cur = root;
	TreeNode* pre = nullptr;

	while (cur) {
		if (cur->val == key) break;
		pre = cur; //更新父节点
		if (cur->val > key) cur = cur->left;
		else cur = cur->right;
	}

	if (!pre) return deleteOps(cur);

	//如果cur是pre的左节点
	if (pre->left && pre->left->val == key) {
		pre->left = deleteOps(pre->left);
	}

	//如果cur是pre的右节点
	if (pre->right && pre->right->val == key) {
		pre->right = deleteOps(pre->right);
	}

	return root;
}
