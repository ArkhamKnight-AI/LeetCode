//递归写法
bool process(TreeNode* cur, int count) {
	//终止条件
	if (!count && !cur->left && !cur->right) return true;
	if (!cur->left && !cur->right) return false;

	if (cur->left) {
		if (process(cur->left, count - cur->left->val)) return true;
	}

	if (cur->right) {
		if (process(cur->right, count - cur->right->val)) return true;
	}

	return false;
}

bool hasPathSum(TreeNode* root, int targetSum) {
	if (!root) return false;

	return process(root, targetSum - root->val);
}


//非递归写法
bool hasPathSum(TreeNode* root, int targetSum) {
	if (!root) return false;

	stack<pair<TreeNode*, int>> s;

	s.push({ root, root->val });

	while (!s.empty()) {
		auto cur = s.top();
		s.pop();

		if (!cur.first->left && !cur.first->right && cur.second == targetSum) return true;
		
		if (cur.first->right) {
			s.push({ cur.first->right, cur.second + cur.first->right->val });
		}

		if (cur.first->left) {
			s.push({ cur.first->left, cur.second + cur.first->left->val });
		}
	}

	return false;
}
