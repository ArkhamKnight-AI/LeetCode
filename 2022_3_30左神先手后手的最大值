注意:
1.先手函数是可以做选择的 所以是最大值
2.后手函数无法做选择 所以去最小值

#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

//先手函数 我先拿
int s(vector<int>& arr, int L, int R);
int f(vector<int>& arr, int L, int R) {
	//base case L == R 只有一张牌 我还先手拿 把唯一的一张拿走
	if (L == R) return arr[R];

	//返回我后手在arr[L + 1, ... , R](别人拿了L位置的牌) 和 arr[L, ..., R - 1](别人拿了R-1位置的牌)
	//最大的那个 因为我可以先做选择 当然可以拿最大的
	return max(arr[L] + s(arr, L + 1, R), arr[R] + s(arr, L, R - 1));
}

//后手函数 我后拿
int s(vector<int>& arr, int L, int R) {
	//base case L == R 只有一张牌 我后手拿 没有可拿的了
	if (L == R) return 0;

	//返回我先手在arr[L + 1, ... , R](别人拿了L位置的牌) 和 arr[L, ..., R - 1](别人拿了R-1位置的牌)
	//因为我是后手拿的 所以别人会把最坏的牌留给我 因此取最小
	return min(f(arr, L + 1, R), f(arr, L, R - 1));
}

//先手后手 最大的值
int win(vector<int>& arr) {
	if (arr.size() < 1) return 0;

	return max(f(arr, 0, arr.size() - 1), s(arr, 0, arr.size() - 1));
}


int main(void) {
	vector<int> arr = { 1,2,100,4 };
	cout << win(arr) << endl;
	system("pause");
	return 0;
}
