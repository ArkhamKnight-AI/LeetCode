struct TreeNode {
	int val;
	TreeNode *left;
	TreeNode *right;
	TreeNode() : val(0), left(nullptr), right(nullptr) {}
	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
	TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

TreeNode* process(vector<int>& inorder, vector<int>& postorder, int inl, int inr, int posl, int posr) {
	if (posl > posr) return nullptr;
	if (posl == posr) return new TreeNode(postorder[posl]);

	int curval = postorder[posr];
	//后序遍历最后一个元素是当前头结点
	TreeNode* node = new TreeNode(curval);

	//找到头结点在中序遍历数组中的位置
	int k = 0;
	for (int i = 0; i < inorder.size(); i++) {
		if (inorder[i] == curval) {
			k = i;
			break;
		}
	}
	
	//中序数组中左树起止位置：(inl, k - 1) 右树起止位置：(k + 1, inr) 左子树规模为k - inl
	//后序数组中左树起止位置：(posl, posl + k - inl - 1) 右树起止位置：(posl + k - inl, posr - 1)
	TreeNode* left = process(inorder, postorder, inl, k - 1, posl, posl + k - inl - 1);
	TreeNode* right = process(inorder, postorder, k + 1, inr, k - inl + posl, posr - 1);

	node->left = left;
	node->right = right;
	return node;
}

TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
	if (inorder.size() < 1) return nullptr;
	return process(inorder, postorder, 0, inorder.size() - 1, 0, postorder.size() - 1);
}
