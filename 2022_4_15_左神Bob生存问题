注意
1.要开辟(M + 2, N + 2, K + 1)大小的动态规划表 否则会越界
2.1中说到的原因主要是因为有(row - 1, col + 1)这种操作
3.注意辗转相除法的方法

#include<iostream>
#include<vector>
#include<algorithm>
#include<string>
using namespace std;

//辗转相除法求最大公约数
int gcd(int a, int b) {
	if (a == 0 || b == 0) return 0;
	int maxVal = max(a, b);
	int minVal = min(a, b);

	int r = maxVal % minVal;
	while (r != 0) {
		maxVal = minVal;
		minVal = r;
		r = maxVal % minVal;
	}

	return minVal;
}

long process1(int M, int N, int row, int col, int rest) {
	//如果越界就死了
	if (row < 0 || row == M || col < 0 || col == N) return 0;

	//如果剩余步数为0 说明找到了1种活法
	if (rest == 0) return 1;

	//把Bob上下左右移动后的总生存方法数加起来就是总的活法
	long live = process1(M, N, row - 1, col, rest - 1)
		 + process1(M, N, row + 1, col, rest - 1) 
		 + process1(M, N, row, col - 1, rest - 1) 
		 + process1(M, N, row, col + 1, rest - 1);

	return live;
}

string BobLive1(int M, int N, int i, int j, int k) {
	long live = process1(M, N, i, j, k); 
	long total = (long)pow(4, k);
	long maxgcd = gcd(live, total);
	return to_string(live / maxgcd) + "/" + to_string(total / maxgcd);
}


//改动态规划表
//M * N大小的区域 在(i,j)位置随机上下左右移动k步 存活的概率 
string BobLive2(int M, int N, int i, int j, int k) {
	//0~M, 0~N 故大小为(M + 1) * (N + 1)
	vector<vector<vector<long>>> dp(k + 1, vector<vector<long>>(M + 2, vector<long>(N + 2)));

	//rest为0时(第0层) 说明找到了1种活法
	for (int row = 1; row < M; row++) {
		for (int col = 1; col < N; col++) {
			dp[0][row][col] = 1;
		}
	}
	
	//第0层已经填好了
	for (int level = 1; level <= k; level++) {
		for (int row = 1; row <= M; row++) {
			for (int col = 1; col <= N; col++) {
				dp[level][row][col] = dp[level - 1][row - 1][col];
				dp[level][row][col] += dp[level - 1][row + 1][col];
				dp[level][row][col] += dp[level - 1][row][col - 1];
				dp[level][row][col] += dp[level - 1][row][col + 1];
			}
		}
	}

	long live = dp[k][i + 1][j + 1];
	long total = (long)pow(4, k);
	long maxgcd = gcd(total, live);
	return to_string(live / maxgcd) + "/" + to_string(total / maxgcd);
}

int main() {
	int a = 134;
	int b = 18;
	cout << BobLive1(10, 10, 3, 2, 5) << endl;
	cout << BobLive2(10, 10, 3, 2, 5) << endl;
	system("pause");
	return 0;
}
