注意:
0-1背包问题不可以使用贪心算法 小贪心也不行
必须严格使用动态规划的方法
这个题一定要记住解法

class Solution {
public:
    
    int coinChange(vector<int>& coins, int amount) {
        if(coins.size() < 1 || amount < 0) return -1;
        if(amount == 0) return 0;
        vector<int> count(amount);

        return dp(coins, amount);
    }

    int dp(vector<int>& coins, int rest){
        //如果没有剩余要找的了 那么我啥都不用做 直接返回0就行
        if(rest == 0) return 0;
        //如果res<0 说明没有方法可以让rest正好等于0 返回-1
        if(rest < 0) return -1;
        //如果rest-1的地方有值 说明有方法可以让让剩余的钱为rest 且这时的方法数一定是钱数量最少的 那么我就直接去返回它就行了
        //没有这一行会超时
        if(count[rest - 1] != 0) return count[rest - 1];

        //遍历整个coins 看使用哪一个coin可以使总数量最少
        //设置最小次数为整数最大
        int Min = INT_MAX;

        for(auto coin : coins){
            //如果选i号货币的结果次数
            int res = dp(coins, rest - coin);
            //如果有结果 且这个结果比当前最小值还要小
            if(res >= 0 && res < Min){
                //加上当前的这一个货币 更新Min的值
                Min = res + 1;
            }
        }
        //如果有方法可以生成rest的结果 就返回这个最小需要的硬币数 否则返回-1
        count[rest - 1] = Min == INT_MAX ? -1 :Min;
        return count[rest - 1];
    }
};
