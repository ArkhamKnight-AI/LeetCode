#include<iostream>
#include<vector>
#include<string>
#include<algorithm>
using namespace std;

//最长无重复字符子串的长度
//有两种瓶颈：
//1.以i-1结尾的数向左推的位置   z...d g f e d c b a z  当前i位置的数是z 此时的瓶颈是d上次出现的位置 pre在s[i]='d'的时候就更新了 直到遇到下次瓶颈1时才会更新
//2.i位置的数上一次出现的位置   d g e d c b a e...     当前i位置的数是a 此时的瓶颈是e上次出现的位置 此时需要更新pre的值
int lengthOfNoRepeat(string& s) {
	if (s.size() < 2) return s.size();

	//记录每个字符上一次出现的位置
	vector<int> map(256);

	for (int i = 0; i < map.size(); i++) {
		map[i] = -1;
	}


	//上一次出现这个字符的位置
	//只有在遇到瓶颈1的时候才会更新pre的值
	int pre = -1;

	//最长的长度是多少
	int maxLen = 0;

	//以i位置结尾的最长无重复子串长度
	int cur = 0;

	for (int i = 0; i < s.size(); i++) {
		pre = max(pre, map[s[i]]);
		cur = i - pre;
		maxLen = max(cur, maxLen);
		map[s[i]] = i;
	}

	return maxLen;
}

int main() {
	string s = "pwwkew";
	cout << lengthOfNoRepeat(s) << endl;
	system("pause");
	return 0;
} 
