#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

vector<vector<int>> matrixMulti(vector<vector<int>>& m1, vector<vector<int>>& m2);
vector<vector<int>> matrixPower(vector<vector<int>>& matrix, int p);
int fib(int n) {
	if (n == 1 || n == 2) return 1;

	vector<vector<int>> mat = { {1, 1}, {1, 0} };

	vector<vector<int>> res = matrixPower(mat, n - 2);

	return res[0][0] + res[1][0];
}

//矩阵次方运算
vector<vector<int>> matrixMulti(vector<vector<int>>& m1, vector<vector<int>>& m2);
vector<vector<int>> matrixPower(vector<vector<int>>& matrix, int p) {
	vector<vector<int>> res(matrix.size(), vector<int>(matrix.size()));

	//初始化res为单位矩阵
	for (int i = 0; i < res.size(); i++) {
		res[i][i] = 1;
	}

	vector<vector<int>> t = matrix;

	for (; p != 0; p = (p >> 1)) {
		//二进制的某一位不为0 就把它乘进来
		if (p & 1 != 0) {
			res = matrixMulti(res, t);
		}

		//更新t
		t = matrixMulti(t, t);
	}

	return res;
}

//矩阵乘法
vector<vector<int>> matrixMulti(vector<vector<int>>& m1, vector<vector<int>>& m2) {
	vector<vector<int>> res(m1.size(), vector<int>(m2[0].size()));

	for (int i = 0; i < m1.size(); i++) {
		for (int j = 0; j < m2[0].size(); j++) {
			for (int k = 0; k < m1[0].size(); k++) {
				res[i][j] += m1[i][k] * m2[k][j];
			}
		}
	}

	return res;
}

int main() {
	/*vector<vector<int>> m1 = { {1, 2},{3, 4} };
	vector<vector<int>> m2 = { {1, 1}, {1, 1} };
	vector<vector<int>> res = matrixPower(m1, 3);
	for (int i = 0; i < res.size(); i++) {
		for (int j = 0; j < res[0].size(); j++) {
			cout << res[i][j] << " ";
		}
		cout << endl;
	}*/
	cout << fib(43) << endl;
	system("pause");
	return 0;
}  
