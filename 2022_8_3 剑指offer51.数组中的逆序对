//归并排序的变形！！！
class Solution {
public:
	int res = 0;

	void merge(vector<int>& arr, int L, int mid, int R) {
		int p1 = mid;
		int p2 = R;
		int index = R - L;
		vector<int> help(R - L + 1);

		//每一轮排好一个数
		while (p1 >= L && p2 >= mid + 1) {
			if(arr[p1] > arr[p2]) {
				//左区间的大小是p1 ~ mid 右区间为mid + 1 ~ p2
				res += (p2 - mid);
			}
			help[index--] = arr[p1] > arr[p2] ? arr[p1--] : arr[p2--];
		}

		while (p1 >= L) {
			help[index--] = arr[p1--];
		}

		while (p2 >= mid + 1) {
			help[index--] = arr[p2--];
		}

		for (int i = 0; i < help.size(); i++) {
			arr[L + i] = help[i];
		}
	}

	//在每个区间上的排序过程：先把左边排好 再把右边排好 最后merge
	void mergeSort(vector<int>& arr, int L, int R) {
		if (L >= R) return;

		//先把左侧排好序 再把右侧排好序 然后递归进行
		int mid = (R + L) >> 1;
		mergeSort(arr, L, mid);
		mergeSort(arr, mid + 1, R);
		merge(arr, L, mid, R);
	}

	int inversePairs(vector<int>& nums) {
		if (nums.size() <= 1) return 0;
		mergeSort(nums, 0, nums.size() - 1);

		return res;
	}
};
