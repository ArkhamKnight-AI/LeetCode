#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;

//给定coins数组和target 返回最少硬币数

//1.尝试的递归版本
//当前来到index位置 还要组成rest的钱数
int process1(vector<int>& coins, int index, int rest) {
	//来到了终止位置 没有凑够 说明这种方法不行
	if (index == coins.size()) return -1;

	//剩余钱数少于0 说明这种方法不行
	if (rest < 0) return -1;
	
	//剩余钱数等于0 说明此时不需要再用硬币了 返回0
	if (rest == 0) return 0;

	//中间过程
	//不要当前的硬币
	int p1 = process1(coins, index + 1, rest);
	//要当前的硬币
	int p2 = process1(coins, index + 1, rest - coins[index]);
	  
	//如果p1或者p2返回-1会对结果有影响
	//p1和p2都为-1表示当前的尝试方法不可能得到rest这么多钱
	if (p1 == -1 && p2 == -1) {
		return -1;
	}
	//p1和p2不全为0
	else {
		//p1为-1时 返回p2+1
		if (p1 == -1) {
			return p2 + 1;
		}
		//p2为-1时 返回p1
		if(p2 == -1) {
			return p1;
		}
	}

	//都不为-1 返回最小值
	return min(p1, p2 + 1);
}

int minCoins1(vector<int>& coins, int target) {
	return process1(coins, 0, target);
}

//2.尝试改记忆化搜索
int process2(vector<int>& coins, int index, int rest, vector<vector<int>>& dp) {
	//无效解(认为是计算过的)
	if (rest < 0) return -1;

	//计算过的解直接返回
	if (dp[index][rest] != -2) {
		return dp[index][rest];
	}
	else { //没有计算过的解
		if (rest == 0) {
			dp[index][rest] = 0;
		}
		else if (index == coins.size()) {
			dp[index][rest] = -1;
		}
		else {
			//不选择index位置的货币
			int p1 = process2(coins, index + 1, rest, dp);

			//选择了index位置的货币
			int p2 = process2(coins, index + 1, rest - coins[index], dp);
			
			//如果选或不选index位置的数都不能使rest为0 说明当前决策错了 返回-1
			if (p1 == -1 && p2 == -1) {
				dp[index][rest] = -1;
			}
			else {
				//说明选了index位置的硬币是不行的
				if (p1 == -1) {
					dp[index][rest] = p2 + 1;
				}
				else if (p2 == -1) {
					dp[index][rest] = p1;
				}
				else {
					dp[index][rest] = min(p1, p2 + 1);
				}
			}
		}
	}
	return dp[index][rest];
}

int minCoins2(vector<int>& coins, int target) {
	vector<vector<int>> dp(coins.size() + 1, vector<int>(target + 1));
	for (int i = 0; i < dp.size(); i++) {
		for (int j = 0; j < dp[0].size(); j++) {
			dp[i][j] = -2;
		}
	}

	return process2(coins, 0, target, dp);
}


//3.严格表结构的动态规划方法
int minCoins3(vector<int>& coins, int target) {
	int N = coins.size();
	vector<vector<int>> dp(N + 1, vector<int>(target + 1));

	for (int i = 0; i <= N; i++) {
		dp[i][0] = 0;
	}

	for (int i = 1; i <= target; i++) {
		dp[N][i] = -1;
	}

	//每个位置依赖的是它 下方 和 左下方的值
	//从左到右 从下往上进行计算
	for (int index = N - 1; index >= 0; index--) {
		for (int rest = 1; rest <= target; rest++) {
			int p1 = dp[index + 1][rest];
			int p2 = rest - coins[index] < 0 ? -1 : dp[index + 1][rest - coins[index]];
			if (p1 == -1 && p2 == -1) {
				dp[index][rest] = -1;
			}
			//p1和p2不全为0
			else {
				//p1为-1时 返回p2+1
				if (p1 == -1) {
					dp[index][rest] = p2 + 1;
				}
				//p2为-1时 返回p1
				if (p2 == -1) {
					dp[index][rest] = p1;
				}
			}
		}
	}
	//看尝试版本递归调用的是哪个位置的值
	return dp[0][target];
}


int main() {
	
	system("pause");
	return 0;
}
