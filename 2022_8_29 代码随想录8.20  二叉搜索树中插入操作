struct TreeNode {
	int val;
	TreeNode *left;
	TreeNode *right;
	TreeNode() : val(0), left(nullptr), right(nullptr) {}
	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} 
	TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

//带有返回值的递归方法
TreeNode* process(TreeNode* cur, int val) {
	//如果找到了空节点 就把这个元素放在这儿
	if (!cur) return new TreeNode(val);

	if (cur->val > val) cur->left = process(cur->left, val);
	if (cur->val < val) cur->right = process(cur->right, val);

	return cur;
}

TreeNode* insertIntoBST(TreeNode* root, int val) {
	if (!root) return new TreeNode(val);
	return process(root, val);
}

//不带返回值的递归方法(用一个成员变量->父节点)
class Solution {
public:
	TreeNode* parent;
	TreeNode* insertIntoBST(TreeNode* root, int val) {
        if(!root) return new TreeNode(val);
		process(root, val);
        return root;
	}

	void process(TreeNode* root, int val) {
		if (!root) {
			TreeNode* node = new TreeNode(val);
			if (parent && parent->val > val) parent->left = node;
			else parent->right = node;
            return;
		}
		parent = root; //更新父节点

		if(root->val > val) process(root->left, val);
		else process(root->right, val);
	}
};

//迭代方法
TreeNode* insertIntoBST(TreeNode* root, int val) {
	if (!root) return new TreeNode(val);

	auto cur = root;
	while (cur) {
		//当前节点值小于val 则应该向右子树遍历
		if (cur->val < val) {
			//右子树为空直接填上去就行
			if (!cur->right) {
				cur->right = new TreeNode(val);
				break;
			}
			cur = cur->right;
		}
		//当前节点值大于val 则应该向左子树遍历
		else {
			if (!cur->left) {
				cur->left = new TreeNode(val);
				break;
			}
			cur = cur->left;
		}
	}
	return root;
}
