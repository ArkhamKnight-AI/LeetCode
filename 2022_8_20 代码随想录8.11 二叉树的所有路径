struct TreeNode {
	int val;
	TreeNode* left;
	TreeNode* right;
	TreeNode(int v) : val(v), left(nullptr), right(nullptr) {}
};

//递归写法
void process(vector<string>& res, vector<int>& path, TreeNode* cur) {
	//来到了叶子节点 把路径上的结果放入res中
	path.push_back(cur->val);
	if (!cur->left && !cur->right) {
		string curres;
		for (int i = 0; i < path.size() - 1; i++) {
			curres += to_string(path[i]);
			curres += "->";
		}

		curres += to_string(path[path.size() - 1]);
		res.push_back(curres);
	}

	if (cur->left) {
		process(res, path, cur->left);
		path.pop_back();
	}

	if (cur->right) {
		process(res, path, cur->right);
		path.pop_back();
	}
}

vector<string> binaryTreePaths(TreeNode* root) {
	vector<string> res;
	if (!root) return res;

	vector<int> path; //存储路径上的节点

	process(res, path, root);

	return res;
}

//非递归写法
vector<string> binaryTreePaths(TreeNode* root) {
	vector<string> res;
	if (!root) return res;

	stack<TreeNode*> nodes; //存放节点的栈
	stack<string> strings; //存放字符串的栈

	nodes.push(root);
	strings.push(to_string(root->val));

	while (!nodes.empty()) {
		TreeNode* cur = nodes.top(); nodes.pop();
		string curstr = strings.top(); strings.pop();

		if (!cur->left && !cur->right) {
			res.push_back(curstr);
		}

		if (cur->left) {
			nodes.push(cur->left);
			strings.push(curstr + "->" + to_string(cur->left->val));
		}

		if (cur->right) {
			nodes.push(cur->right);
			strings.push(curstr + "->" + to_string(cur->right->val));
		}
	}

	return res;
}
